ml_switcheroo.core.hooks
========================

.. py:module:: ml_switcheroo.core.hooks

.. autoapi-nested-parse::

   Plugin Registry, Hook Context, and Dynamic Loader.

   This module provides the infrastructure for extending ml-switcheroo via plugins.
   It enables developers to intercept and modify the Abstract Syntax Tree (AST)
   during the conversion process using a hook-based system.

   How to write a Plugin
   ---------------------

   A plugin is a simple Python function decorated with ``@register_hook``. It receives
   the current AST node (typically ``cst.Call``, but can be others like ``cst.For``)
   and a context object.

   Usage
   -----
   .. code-block:: python

       @register_hook("my_custom_trigger")
       def transform_node(node: cst.CSTNode, ctx: HookContext) -> cst.CSTNode:
           # Logic
           return node



Attributes
----------

.. autoapisummary::

   ml_switcheroo.core.hooks.SemanticsManagerType
   ml_switcheroo.core.hooks.T
   ml_switcheroo.core.hooks.ArgInjectorType
   ml_switcheroo.core.hooks.PreambleInjectorType
   ml_switcheroo.core.hooks.HookFunction


Classes
-------

.. autoapisummary::

   ml_switcheroo.core.hooks.HookContext


Functions
---------

.. autoapisummary::

   ml_switcheroo.core.hooks.register_hook
   ml_switcheroo.core.hooks.get_hook
   ml_switcheroo.core.hooks.clear_hooks
   ml_switcheroo.core.hooks.load_plugins


Module Contents
---------------

.. py:data:: SemanticsManagerType

.. py:data:: T

.. py:data:: ArgInjectorType

.. py:data:: PreambleInjectorType

.. py:class:: HookContext(semantics: SemanticsManagerType, config: ml_switcheroo.config.RuntimeConfig, arg_injector: Optional[ArgInjectorType] = None, preamble_injector: Optional[PreambleInjectorType] = None)

   Context object passed to every plugin hook during transcoding.

   Provides read-only access to global state and write access
   to specific injection points (signature args, function body preambles).


   .. py:attribute:: semantics


   .. py:attribute:: source_fw


   .. py:attribute:: target_fw


   .. py:attribute:: metadata
      :type:  Dict[str, Any]


   .. py:method:: inject_signature_arg(name: str, annotation: Optional[str] = None) -> None

      Requests injection of an argument into the current function signature.



   .. py:method:: inject_preamble(code_str: str) -> None

      Requests injection of a statement at the beginning of the function body.



   .. py:method:: raw_config(key: str, default: Any = None) -> Any

      Retrieve a raw value from the unstructured plugin settings dict.



   .. py:method:: config(key: str, default: Any = None) -> Any

      Legacy alias for raw_config.



   .. py:method:: validate_settings(model: Type[T]) -> T

      Validates global config against a Plugin-specific Pydantic schema.



   .. py:method:: lookup_api(op_name: str) -> Optional[str]

      Resolves target framework's API string for a given standard operation.



   .. py:method:: lookup_signature(op_name: str) -> List[str]

      Retrieves standard argument list for a given operation.



.. py:data:: HookFunction

.. py:function:: register_hook(trigger: str) -> Callable[[HookFunction], HookFunction]

   Decorator to register a function as a plugin hook.

   :param trigger: The unique identifier. Can be an operation ID or a
                   reserved system event like "transform_for_loop".


.. py:function:: get_hook(trigger: str) -> Optional[HookFunction]

   Retrieves a registered hook function by its trigger name.


.. py:function:: clear_hooks() -> None

   Resets the internal hook registry.


.. py:function:: load_plugins(plugins_dir: Optional[pathlib.Path] = None, extra_dirs: Optional[List[pathlib.Path]] = None) -> int

   Dynamically imports all modules in the plugins directory.


