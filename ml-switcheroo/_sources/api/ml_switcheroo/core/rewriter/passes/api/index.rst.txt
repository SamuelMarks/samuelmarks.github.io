ml_switcheroo.core.rewriter.passes.api
======================================

.. py:module:: ml_switcheroo.core.rewriter.passes.api

.. autoapi-nested-parse::

   API Logic Pass.

   This module consolidates all API-level transformations, including:
   1.  **Function Calls**: Remapping APIs (e.g., `torch.abs` -> `jnp.abs`), applying argument normalization,
       handling layout permutations, and executing transformation strategies (infix, lambda, macros).
   2.  **Attributes**: Remapping attributes/constants (e.g., `torch.float32` -> `jnp.float32`).
   3.  **Assignments**: Unwrapping functional return patterns (e.g., `layer.apply`).
   4.  **Symbol Resolution**: Resolving aliases to fully qualified names for lookup.
   5.  **Scoping**: Tracking stateful variables (layers) to inform call rewriting logic.



Classes
-------

.. autoapisummary::

   ml_switcheroo.core.rewriter.passes.api.ApiPass
   ml_switcheroo.core.rewriter.passes.api.ApiTransformer


Module Contents
---------------

.. py:class:: ApiPass

   Bases: :py:obj:`ml_switcheroo.core.rewriter.interface.RewriterPass`


   Transformation pass for rewiring API usage.

   Handles resolving function calls to Abstract Operations (The Hub) and then projecting
   them to the Target Framework (The Spoke). Also handles attribute renaming and
   stateful assignment tracking.


   .. py:method:: transform(module: libcst.Module, context: ml_switcheroo.core.rewriter.context.RewriterContext) -> libcst.Module

      Executes the API transformation logic.

      :param module: The source CST.
      :param context: Shared rewriter state.

      :returns: The transformed CST.



.. py:class:: ApiTransformer(context: ml_switcheroo.core.rewriter.context.RewriterContext)

   Bases: :py:obj:`libcst.CSTTransformer`


   LibCST Transformer for API Logic.

   This class centralizes the logic for:
   - Resolving names/aliases.
   - Tracking scope/state.
   - Rewriting Calls, Attributes, and Assignments.


   .. py:attribute:: context


   .. py:property:: semantics
      :type: ml_switcheroo.semantics.manager.SemanticsManager


      Accessor for semantics manager.


   .. py:property:: config
      :type: ml_switcheroo.config.RuntimeConfig


      Accessor for runtime config.


   .. py:property:: source_fw
      :type: str


      Accessor for source framework key.


   .. py:property:: target_fw
      :type: str


      Accessor for target framework key.


   .. py:property:: strict_mode
      :type: bool


      Accessor for strict mode flag.


   .. py:property:: source_traits
      :type: ml_switcheroo.semantics.schema.StructuralTraits


      Lazily loads source framework traits.


   .. py:method:: check_version_constraints(min_v: Optional[str], max_v: Optional[str]) -> Optional[str]

      Checks if target version requirements are met.



   .. py:method:: leave_Module(original_node: libcst.Module, updated_node: libcst.Module) -> libcst.Module

      Injects accumulated module-level preamble statements if they haven't been flushed yet
      by a prior pass (like StructuralPass). We deduplicate based on string content.



   .. py:method:: visit_ClassDef(node: libcst.ClassDef) -> Optional[bool]

      Enter class scope and detect Module.



   .. py:method:: leave_ClassDef(original_node: libcst.ClassDef, updated_node: libcst.ClassDef) -> libcst.ClassDef

      Exit class scope.



   .. py:method:: visit_FunctionDef(node: libcst.FunctionDef) -> Optional[bool]

      Enter function scope.



   .. py:method:: leave_FunctionDef(original_node: libcst.FunctionDef, updated_node: libcst.FunctionDef) -> libcst.FunctionDef

      Exit function scope.
      Flush any pending preamble statements requested by plugins during this pass.
      Also apply any pending signature injections (arguments).



   .. py:method:: visit_SimpleStatementLine(node: libcst.SimpleStatementLine) -> Optional[bool]

      Reset statement-level error buffers.



   .. py:method:: leave_SimpleStatementLine(original_node: libcst.SimpleStatementLine, updated_node: libcst.SimpleStatementLine) -> Union[libcst.SimpleStatementLine, libcst.FlattenSentinel]

      Check for errors generated by child expressions and wrap if needed.



   .. py:method:: visit_Import(node: libcst.Import) -> Optional[bool]

      Track import aliases.



   .. py:method:: visit_ImportFrom(node: libcst.ImportFrom) -> Optional[bool]

      Track from-import aliases.



   .. py:method:: leave_Assign(original_node: libcst.Assign, updated_node: libcst.Assign) -> libcst.Assign

      Handle assignment rewriting.
      1. Track stateful initializations (e.g. self.layer = Linear...).
      2. Unwrap functional returns (e.g. y, state = layer.apply...).



   .. py:method:: leave_Attribute(original_node: libcst.Attribute, updated_node: libcst.Attribute) -> libcst.Attribute | libcst.Name | libcst.CSTNode

      Rewrites attributes and constants (e.g. torch.float32).



   .. py:method:: leave_Call(original_node: libcst.Call, updated_node: libcst.Call) -> Union[libcst.Call, libcst.BinaryOperation, libcst.UnaryOperation, libcst.CSTNode]

      Main entry point for function call rewriting.



   .. py:property:: ctx
      :type: Any


      Expose hook context for strategy invocation.


