ml_switcheroo.utils.code_extractor
==================================

.. py:module:: ml_switcheroo.utils.code_extractor

.. autoapi-nested-parse::

   Utility to extract source code from live Python objects.

   This module solves the "Split-Brain" issue between the core logic and generated harnesses.
   Instead of duplicating code manually into template strings, this utility uses the `inspect`
   module to read the source code of classes (like the Fuzzer) at runtime.

   It ensures that:
   1.  Imports required by the class are captured or re-synthesized.
   2.  Class definitions are extracted cleanly.
   3.  Dependencies (like helper methods or constants) are resolved.



Classes
-------

.. autoapisummary::

   ml_switcheroo.utils.code_extractor.CodeExtractor


Module Contents
---------------

.. py:class:: CodeExtractor

   Extracts self-contained source code for Python classes or functions.


   .. py:method:: extract_class(cls_obj: Type[Any]) -> str
      :staticmethod:


      Reads the source code of a class and formats it for injection.

      :param cls_obj: The class object to extract (e.g. `InputFuzzer`).
      :type cls_obj: Type[Any]

      :returns: The full source code string of the class definition.
      :rtype: str

      :raises OSError: If source code cannot be retrieved (e.g. purely compiled C modules).
      :raises TypeError: If input is not a class.



   .. py:method:: normalize_harness_imports(source_code: str, required_modules: List[str]) -> str
      :staticmethod:


      Prepends necessary imports to a code block to ensure it is standalone.

      Since extracted code loses its module-level imports, we must reinject them.

      :param source_code: The extracted class body.
      :type source_code: str
      :param required_modules: List of modules to import (e.g. ['random', 'numpy']).
      :type required_modules: List[str]

      :returns: The source code with import statements prepended.
      :rtype: str



