ml_switcheroo.discovery.layers
==============================

.. py:module:: ml_switcheroo.discovery.layers

.. autoapi-nested-parse::

   Layer Discovery Subsystem (The Orchestrator).

   This module provides the :class:`LayerDiscoveryBot`, which replaces the old hardcoded
   polyfill logic. Instead of manually importing ``torch`` or ``flax`` and checking specific lists,
   this bot queries the **Framework Registry**.

   It iterates over every installed framework adapter, asks it to ``collect_api()``,
   and feeds those results into the :class:`ConsensusEngine`. This allows the system to
   automagically "learn" that ``mlx.nn.Linear`` corresponds to ``torch.nn.Linear`` without
   explicitly programming that relationship here.

   Usage:
       >>> from ml_switcheroo.discovery.layers import LayerDiscoveryBot
       >>> bot = LayerDiscoveryBot()
       >>> count = bot.run(dry_run=False)



Classes
-------

.. autoapisummary::

   ml_switcheroo.discovery.layers.LayerDiscoveryBot


Module Contents
---------------

.. py:class:: LayerDiscoveryBot

   Automated discovery bot for Neural Layers and Array Operations.

   This class orchestrates the "Consensus Discovery" workflow. It is completely
   agnostic to specific libraries; it relies exclusively on the
   :class:`FrameworkAdapter` protocol to abstract away framework introspection.

   .. attribute:: consensus

      The logic engine for clustering synonyms (e.g., 'dim' vs 'axis').

      :type: ConsensusEngine

   .. attribute:: persister

      The handler that serializes findings to JSON.

      :type: SemanticPersister


   .. py:attribute:: consensus


   .. py:attribute:: persister


   .. py:method:: run(dry_run: bool = False) -> int

      Executes the full discovery process across ALL registered, active frameworks.

      Steps:
      1.  **Harvest**: Iterates specifically over installed frameworks and requests
          their API surfaces via :meth:`collect_api` (Layers, Activations, Losses).
      2.  **Cluster**: Uses the Consensus Engine to group similar concepts
          (e.g., matching ``HuberLoss``, ``huber_loss``, and ``Huber``).
      3.  **Filter**: Discards candidates that don't satisfy the minimum
          support threshold (must exist in at least 2 frameworks to be a Standard).
      4.  **Align**: Determines standard argument names based on voting (e.g.,
          if 3 frameworks use ``axis`` and 1 uses ``dim``, ``axis`` wins).
      5.  **Persist**: Writes findings to ``semantics/k_discovered.json``.

      :param dry_run: If True, performs analysis and logging but does not
                      write to disk. Defects to False.
      :type dry_run: bool

      :returns: The number of new abstract standards identified and staged.
      :rtype: int



