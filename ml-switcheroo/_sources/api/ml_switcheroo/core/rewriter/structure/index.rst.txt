ml_switcheroo.core.rewriter.structure
=====================================

.. py:module:: ml_switcheroo.core.rewriter.structure

.. autoapi-nested-parse::

   Structural Rewriting Logic.

   This module provides the `StructureMixin`, a component of the PivotRewriter
   responsible for transforming the scaffolding of Python code: Class definitions
   and Function definitions.

   It implements logic for:
   1.  **Inheritance Warping**: Swapping framework base classes (e.g., `torch.nn.Module`
       ↔ `flax.nnx.Module` ↔ `keras.Layer`).
   2.  **Signature Transformation**: Injecting or stripping framework-specific
       state arguments (e.g., `rngs`) in constructors.
   3.  **Method Renaming**: Mapping `forward` ↔ `__call__` ↔ `call`.
   4.  **Constructor Logic Injection**: Ensuring `super().__init__()` is present
       when targeting PyTorch or Keras.
   5.  **Type Hint Rewriting**: Mapping type annotations (e.g., `torch.Tensor` -> `jax.Array`)
       in function signatures or variable assignments.
   6.  **Docstring Updates**: Automatically documenting injected arguments.



Classes
-------

.. autoapisummary::

   ml_switcheroo.core.rewriter.structure.StructureMixin


Module Contents
---------------

.. py:class:: StructureMixin(semantics: ml_switcheroo.semantics.manager.SemanticsManager, config: ml_switcheroo.config.RuntimeConfig)

   Bases: :py:obj:`ml_switcheroo.core.rewriter.base.BaseRewriter`


   Mixin for transforming structural elements (Classes, Functions) and Type Hints.

   .. attribute:: _in_module_class

      Inherited from BaseRewriter. True if currently
      traversing a Neural Network Module class.

      :type: bool

   .. attribute:: _signature_stack

      Inherited from BaseRewriter.
      Tracks current function signature state.

      :type: List[SignatureContext]

   .. attribute:: _in_annotation

      Tracks if the visitor is currently inside a type annotation.

      :type: bool


   .. py:method:: visit_ClassDef(node: libcst.ClassDef) -> Optional[bool]

      Visits a class definition to detect Neural Module context.

      It inspects base classes to determine if the class is a framework-specific
      Neural Module (Torch, Flax NNX, or Keras). This sets the `_in_module_class` flag,
      enabling method renaming and signature fixups nested within.

      :param node: The libCST ClassDef node.

      :returns: True to traverse children.



   .. py:method:: leave_ClassDef(_original_node: libcst.ClassDef, updated_node: libcst.ClassDef) -> libcst.ClassDef

      Rewrites class inheritance for the target framework.

      If the class was identified as a Neural Module, this method swaps the
      base class:
      - Target JAX: `...` → `flax.nnx.Module`
      - Target Torch: `...` → `torch.nn.Module`
      - Target Keras/TF: `...` → `keras.Layer`

      :param original_node: The original CST node (unused).
      :param updated_node: The CST node with transformed children.

      :returns: The transformed ClassDef node.



   .. py:method:: visit_FunctionDef(node: libcst.FunctionDef) -> Optional[bool]

      Visits function definitions to track signature context.

      Captures existing arguments to allow smart injection/stripping later.
      Pushes a new `SignatureContext` onto the stack.

      :param node: The CST FunctionDef node.

      :returns: True to traverse children.



   .. py:method:: leave_FunctionDef(_original_node: libcst.FunctionDef, updated_node: libcst.FunctionDef) -> libcst.CSTNode

      Finalizes function transformations.

      Applies:
      1.  **Method Renaming**: `forward` ↔ `__call__` ↔ `call`.
      2.  **Signature Modification**: Injecting/Stripping `rngs` for Flax NNX support.
      3.  **Plugin Injection**: Applying args requested by plugins.
      4.  **Preamble Injection**: Inserting setup code (like `super().__init__()` or RNG split).
      5.  **Docstring Updates**: Appends injected arguments to docstrings.

      :param original_node: The original CST node.
      :param updated_node: The CST node with transformed children.

      :returns: The transformed FunctionDef node.



   .. py:method:: visit_Annotation(node: libcst.Annotation) -> Optional[bool]

      Enters a type annotation node (e.g., `: torch.Tensor` or `-> int`).
      Sets a flag to allow `leave_Name` to rewrite type names.



   .. py:method:: leave_Annotation(original_node: libcst.Annotation, updated_node: libcst.Annotation) -> libcst.Annotation

      Leaves a type annotation node. Resets the annotation flag.



   .. py:method:: leave_Name(original_node: libcst.Name, updated_node: libcst.Name) -> libcst.BaseExpression

      Rewrites Names found within Type Annotations.

      If we are inside an annotation context (e.g., `x: Tensor`), we resolve
      this name via aliases (e.g., `Tensor` -> `torch.Tensor`), look it up
      in the semantics, and rewrite it if a mapping exists (e.g., -> `jax.Array`).

      Note: Calls and Attributes (e.g. `torch.Tensor`) are handled by other mixins
      or `leave_Attribute` regardless of context, but bare `Name` nodes in code
      are usually variables we don't want to touch. This method is scoped strictly
      to annotations to be safe.



